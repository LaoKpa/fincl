# AUTOGENERATED! DO NOT EDIT! File to edit: dev/08_feature_eng.ipynb (unless otherwise specified).

__all__ = ['roll_measure', 'roll_impact', 'kyle', 'amihud', 'autocorr', 'stdev', 'log_ret', 'ffd', 'volratio',
           'stdev_from_ma', 'close', 'lag', 'lag_change', 'lag_diff', 'ema', 'month', 'week', 'day', 'weekday', 'hour',
           'tick_bars', 'run_feature_engineering', 'get_bars', 'fill_out_symbol', 'engineer_feature', 'compute_feature',
           'define_feature_configs', 'SYMBOLS_CSV', 'SYMBOLS_DICT', 'FEATURES']

# Cell
from mlfinlab.microstructural_features import (
    get_roll_measure,
    get_roll_impact,
    get_bar_based_kyle_lambda,
    get_bar_based_amihud_lambda,
)
from copy import deepcopy
import pandas as pd
import numpy as np
import logging
from .load_data import load_feat, save_feat
from .frac_diff import frac_diff_ffd
from .load_data import get_data, SYMBOLS_CSV, safe_feat_name, process_bars

SYMBOLS_CSV = SYMBOLS_CSV.copy()
SYMBOLS_CSV.columns = SYMBOLS_CSV.columns.str.lower()
SYMBOLS_DICT = SYMBOLS_CSV.T.to_dict()


def roll_measure(df, window, price="Close"):
    """The Roll measure attempts to estimate the bid-ask spread (i.e. liquidity) of an instrument"""
    return get_roll_measure(df[price], window)


def roll_impact(df, window, price="Close", dollar_volume="Dollar Volume"):
    """The Roll measure divided by dollar volume"""
    return roll_measure(df, window, price) / df[dollar_volume] * 1e9


def kyle(df, window, price="Close", volume="Volume"):
    """A measure of market impact cost (i.e. liquidity) from Kyle (1985)"""
    return get_bar_based_kyle_lambda(df[price], df[volume], window) * 1e9


def amihud(df, window, price="Close", dollar_volume="Dollar Volume"):
    """A measure of market impact cost (i.e. liquidity) from Amihud (2002)"""
    return get_bar_based_amihud_lambda(df[price], df[dollar_volume], window) * 1e9


def autocorr(df, window, lag, column="Close"):
    """The raw price series' serial correlation"""
    return df[column].rolling(window).apply(lambda x: x.autocorr(lag=lag), raw=False)


def stdev(df, window, column="Close"):
    """The raw price series' standard deviation"""
    return df[column].rolling(window).std()


def log_ret(df, periods=1, column="Close"):
    """First difference of log-transformed prices"""
    return np.log(df[column]).diff(periods=periods)


def ffd(df, d, column="Close"):
    """Fractionally differentiated prices"""
    return frac_diff_ffd(np.log(df[column].to_frame('Close')), d)['Close']


def volratio(df, com, volume="Volume", buy_volume="Buy Volume"):
    """
    EWM of bar-by-bar buy volume divided by total volume
    (i.e. a value >0.50 would indicate buyers driving the market)
    """
    return (df[buy_volume] / df[volume]).ewm(com=com).mean()


def stdev_from_ma(df, window, column="Close"):
    rolly = df[column].rolling(window)
    return (df[column] - rolly.mean()) / rolly.std()


def close(df, column="Close"):
    return df[column]


def lag(df, lag, column="Close"):
    return df[column].shift(lag)


def lag_change(df, lag, column="Close"):
    return df[column].pct_change(lag)


def lag_diff(df, lag, column="Close"):
    col = df[column]
    return col - col.shift(lag)


def ema(df, com, column="Close"):
    return df[column].ewm(com=com).mean()


# Dates
def month(df, column="Time"):
    return df[column].dt.month


def week(df, column="Time"):
    return df[column].dt.week


def day(df, column="Time"):
    return df[column].dt.day


def weekday(df, column="Time"):
    return df[column].dt.weekday


def hour(df, column="Time"):
    return df[column].dt.hour


def tick_bars(df, size, column="Close"):
    return process_bars(df, size, "tick")[column]


FEATURES = {
    "auto": autocorr,
    "stdev": stdev,
    "roll": roll_measure,
    "rollimp": roll_impact,
    "kyle": kyle,
    "amihud": amihud,
    "volratio": volratio,
    "log_ret": log_ret,
    "ffd": ffd,
    "close": close,
    "lag": lag,
    "lag_change": lag_change,
    "ema": ema,
    "stdev_from_ma": stdev_from_ma,

    "time_bars": tick_bars,

    "weekday": weekday,
    "hour": hour,
}

def run_feature_engineering(config, deck):
    """Load already-engineered features or engineer if we can't"""
    for symbol, symbol_deck in deck.items():
        logging.debug(f"{symbol}: Feature engineering for {len(config['features'])} features")
        bars = symbol_deck['bars']
        feats = []
        for feat_config in config["features"]:
            # We pass a copy in so the feat_eng code can modify that to its hearts content,
            # while for us the information remains non-redundant
            name = safe_feat_name(feat_config, safe_for_fs=False)
            feat = engineer_feature(deck, symbol, config, feat_config)["Close"]
            logging.debug(f'Got {feat.shape} shape for feature: {name}')
            feat.name = name
            bars_index = deck[symbol]['bars'].index
            if feat.index.shape != bars_index.shape:
                # We're only interested in values we have prices for
                # Do this now so concat below is fast (and has the same set of indices across)
                feat = feat.reindex(index=bars_index, method='ffill')

            feats.append(feat)
        feats2 = pd.concat(feats, axis=1)
        logging.debug(f"Joined {len(feats)} features into {feats2.shape} shape")
        # Reindex in case of outside feats
        deck[symbol]['feats'] = feats2
    return deck

def get_bars(deck, symbol, config):
    if symbol in deck:
        # TODO: Remove deep copy
        bars = deck[symbol]['bars'].copy(deep=True)
    else:
        # We're loading a feature external to the price data of our trading universe
        bars = get_data(symbol, "minutely", config["start_date"], config["end_date"])

    return bars

def fill_out_symbol(feat_conf, for_symbol):
    symbol = feat_conf['symbol'] = feat_conf.get('symbol', for_symbol)
    if isinstance(symbol, dict):
        feat_conf['symbol'] = fill_out_symbol(symbol, for_symbol)
    return feat_conf


def engineer_feature(deck, for_symbol, config, feat_conf):
    """Parse and compute a feature"""
    feat_conf = deepcopy(feat_conf)
    fill_out_symbol(feat_conf, for_symbol)

    symbol = feat_conf['symbol']

    feat = load_feat(config, feat_conf)
    if feat is not None:
        return feat


    if isinstance(symbol, dict):
        # We're computing a feature on a feature
        df = engineer_feature(deck, for_symbol, config, symbol)
    else:
        df = get_bars(deck, symbol, config)

    feat = compute_feature(deck, for_symbol, config, feat_conf, symbol, df)

    if config["save_to_disk"]:
        save_feat(config, feat_conf, feat)
    return feat

def compute_feature(deck, for_symbol, config, feat_conf, symbol, df):
    logging.debug(f"Computing {feat_conf['name']} for {for_symbol}: {feat_conf}")
    drop = ['name', 'symbol']
    params = {k:v for k, v in feat_conf.items() if not k in drop}

    feat_name = feat_conf['name']
    if feat_name in ['sector', 'exchange']:
        categories = list(sorted(set(SYMBOLS_CSV[feat_name])))
        category = SYMBOLS_DICT[symbol][feat_name]
        feat = pd.Series(categories.index(category), index=df.index)
    else:
        feat = FEATURES[feat_name](df, **params)

    # Every feature's column is called Close to enable easy recursion
    feat = feat.to_frame("Close")

    return feat


def define_feature_configs():
    """Stake out the list of features that is the basis for our features matrix"""
    ffd_f = {"name": "ffd", "d": 0.3}
    log_ret = {"name": "log_ret"}
    vix_1h = {"name": "time_bars", "size": 60, "symbol": 'VIX.XO'}
    log_ret_vix = {"name": "log_ret", "symbol": vix_1h}

    features = [
        log_ret,
        log_ret_vix,
        ffd_f,
    ]
    windows = [10, 25, 50, 250]

    for window in windows:
        features.append({"name": "log_ret", "periods": window})

        features.append({"name": "roll", "window": window})
        features.append({"name": "rollimp", "window": window})
        features.append({"name": "amihud", "window": window})
        features.append({"name": "kyle", "window": window})

        volratio = {"name": "volratio", "com": window}
        stdev_volratio = {"name": "stdev", "window": window, "symbol": volratio}

        features.append(volratio)
        features.append({"name": "lag", "lag": window, "symbol": volratio})

        # Volatilty
        stdev_log_ret_vix = {"name": "stdev", "window": window, "symbol": log_ret_vix}
        features.append(stdev_log_ret_vix)

        stdev_log_ret = {"name": "stdev", "window": window, "symbol": log_ret}
        features.append(stdev_log_ret)
        features.append({"name": "stdev", "window": window, "symbol": stdev_log_ret})

        stdev_ffd = {"name": "stdev", "window": window, "symbol": ffd_f}
        features.append(stdev_ffd)

        for lag in windows:
            if lag < window:
                features.append({"name": "auto", "window": window, "lag": lag, "symbol": log_ret_vix})
                features.append({"name": "auto", "window": window, "lag": lag, "symbol": volratio})
                features.append({"name": "auto", "window": window, "lag": lag, "symbol": stdev_volratio})




    return features
